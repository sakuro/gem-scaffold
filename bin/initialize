#!/usr/bin/env zsh

autoload -U colors
colors
# prefix for -x
PS4="${fg[cyan]}[$0:t]$reset_color "
# prefix for stdout
exec > >(sed -e "s/^/${fg[magenta]}[$0:t]$reset_color /")

set -euxo pipefail

# Change to project root directory
cd "${0:h}/.."

# Check required commands
for cmd in gh git mise; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "Error: Required command '$cmd' is not installed" >&2
    exit 1
  fi
done


# Add indentation to each line of input
# Usage: indent N [INPUT]
# Example: echo "hello\nworld" | indent 2
function indent()
{
  local n=$1
  local spaces=$(printf '%*s' $((n * 2)) '')
  sed "/./s/^/$spaces/"
}

# Wrap content with module declaration
# Usage: wrap-module MODULE_NAME CONTENT
# Example: wrap-module MyModule "VERSION = \"1.0.0\""
function wrap-module()
{
  local module_name=$1
  local content=$2

  echo "module $module_name"
  echo "$content" | indent 1
  echo "end"
}

# Wrap content with multiple module declarations (from innermost to outermost)
# Usage: wrap-modules CONTENT MODULE_NAMES_ARRAY
# Example: wrap-modules "VERSION = \"1.0.0\"" module_names
function wrap-modules()
{
  local content=$1
  local array_name=$2

  # Use (P) flag for indirect parameter expansion (zsh way)
  local -a names
  names=("${(@P)array_name}")

  # Wrap from innermost to outermost module
  for ((i=${#names[@]}-1; i>=0; i--)); do
    content=$(wrap-module "${names[$i+1]}" "$content")
  done

  echo "$content"
}

# Generate cron schedule expression from random data
# Usage: cron-schedule
# Output: '16 8 2-8 1,4 *' (minute: 1-59, hour: 1-23, days 2-8 of Jan/Apr)
function cron-schedule()
{
  # Read 8 bytes from /dev/urandom and convert to unsigned 64-bit integer
  local random_raw=$(od -An -N8 -tu8 /dev/urandom)
  local random=${random_raw// /}

  # Convert random number to minute (1-59) and hour (1-23), excluding 0
  local minute=$((random % 59 + 1))
  local hour=$(((random / 100) % 23 + 1))

  # Output cron expression for twice-yearly Ruby version checks
  echo "'$minute $hour 2-8 1,4 *'"
}

# Generate README.md with gem documentation
function generate-readme()
{
  cat > README.md <<EOF
# ${class_name}

TODO: Add a brief description of what this gem does.

## Installation

Add this line to your application's Gemfile:

\`\`\`ruby
gem '${repo_name}'
\`\`\`

And then execute:

\`\`\`bash
bundle install
\`\`\`

Or install it yourself as:

\`\`\`bash
gem install ${repo_name}
\`\`\`

## Usage

\`\`\`ruby
require '${path_name}'

# TODO: Add usage examples
\`\`\`

## Development

After checking out the repo, run \`bin/setup\` to install dependencies. Then, run \`rake spec\` to run the tests. You can also run \`bin/console\` for an interactive prompt that will allow you to experiment.

## Contributing

Bug reports and pull requests are welcome on GitHub at ${repo_url}.

## License

TODO: Specify your license here.

This product is generated from the [gem-scaffold](https://github.com/sakuro/gem-scaffold) template.
While gem-scaffold itself is MIT licensed, the main code can be redistributed under the license chosen by the author after generation.
EOF
}

# Configure GitHub repository settings via API
function configure-github-settings()
{
  echo ""
  echo "Configuring GitHub repository settings..."

  # Set workflow permissions to read/write and allow PR creation
  if gh api --method PUT repos/:owner/:repo/actions/permissions/workflow \
    -f default_workflow_permissions=write \
    -F can_approve_pull_request_reviews=true 2>/dev/null; then
    echo "✓ Workflow permissions set to 'Read and write'"
    echo "✓ GitHub Actions allowed to create and approve pull requests"
  else
    echo "⚠ Could not configure workflow permissions (may need to be set manually)"
  fi

  # Create release environment
  if gh api --silent --method PUT repos/:owner/:repo/environments/release; then
    echo "✓ Created 'release' environment"
  else
    echo "⚠ Could not create 'release' environment (may need to be created manually)"
  fi
}

# Print completion message with next steps
function print-completion-message()
{
  cat <<'EOF'

==========================================
✓ Gem initialization complete!
==========================================

Next steps:
  1. Configure RubyGems Trusted Publishing at:
     https://rubygems.org/oidc/pending_trusted_publishers

  2. Review the release preparation checklist:
     See .github/workflows/release-preparation.yml for details

  3. Check the license files:
     MIT License generated in LICENSE.txt
     To use a different license, replace and commit before pushing

     Template code follows MIT License in LICENSE-TEMPLATE.txt

  4. Push your changes:
     git push -f origin main

EOF
}

# Update Ruby Versions workflow schedule
cron_schedule=$(cron-schedule)
sed -i.bak \
  -e "s|# Run at .* UTC .*|# Run at repository-specific time on Jan 2-8 and Apr 2-8 to distribute API load|" \
  -e "s|cron: '[^']*'|cron: $cron_schedule|" \
  .github/workflows/update-ruby-versions.yml
rm -f .github/workflows/update-ruby-versions.yml.bak

# Trust mise configuration to use correct Ruby version
mise trust

# Replace gem names based on current repository name
repo_name=${PWD:t}
path_name=${repo_name//-/\/}
underscore_name=${repo_name//-/_}

# Generate module nesting for Ruby files
# Example: "my-awesome-gem" -> ["My", "Awesome", "Gem"]
# Example: "my-foo_bar-gem" -> ["My", "FooBar", "Gem"]
IFS='-' read -rA parts <<< "$repo_name"
module_names=()
for part in "${parts[@]}"; do
  # Convert foo_bar to FooBar (capitalize after _ and remove _)
  module_names+=($(echo "$part" | sed -E 's/(^|_)(.)/\U\2/g'))
done

# Generate class name with :: separator from module_names
class_name="${(j.::.)module_names}"

# Get author information from git config
author_name=$(git config user.name)
author_email=$(git config user.email)
current_year=$(print -P '%D{%Y}')

# Get repository URL from GitHub
repo_url=$(gh repo view --json url -q .url)

# Replace content in files (README.md is excluded as it contains template instructions)
# Note: lib/sig files are excluded as they will be completely rewritten later
files_to_update=(
  bin/console
  gem-scaffold.gemspec
  spec/spec_helper.rb
)

for file in "${files_to_update[@]}"; do
  [[ -f "$file" ]] || continue
  sed -i.bak \
    -e "s/gem-scaffold/$repo_name/g" \
    -e "s/Gem::Scaffold/$class_name/g" \
    -e "s|gem/scaffold|$path_name|g" \
    "$file"
  rm -f "$file.bak"
done

# Restore executable bit on bin/console (lost during sed inplace edit)
chmod +x bin/console

# Rename gemspec file
git mv gem-scaffold.gemspec "${repo_name}.gemspec"

# Update author information and URLs in gemspec
sed -i.bak \
  -e "s/spec.authors = \\[\"[^\"]*\"\\]/spec.authors = [\"$author_name\"]/" \
  -e "s/spec.email = \\[\"[^\"]*\"\\]/spec.email = [\"$author_email\"]/" \
  -e "s|spec.homepage = \"[^\"]*\"|spec.homepage = \"$repo_url\"|" \
  "${repo_name}.gemspec"
rm -f "${repo_name}.gemspec.bak"

# Preserve template's MIT license
cp LICENSE.txt LICENSE-TEMPLATE.txt

# Update LICENSE.txt with current year and author
sed -i.bak \
  -e "s/Copyright (c) [0-9]\\{4\\} .*/Copyright (c) $current_year $author_name/" \
  LICENSE.txt
rm -f LICENSE.txt.bak

# Get latest zeitwerk version and update gemspec
zeitwerk_version=$(mise exec -- gem search --remote --exact zeitwerk | grep "^zeitwerk" | sed -E 's/^zeitwerk \(([0-9]+\.[0-9]+)\..*/\1/')
sed -i.bak \
  -e "s/\"zeitwerk\", \"~> [0-9.]*\"/\"zeitwerk\", \"~> $zeitwerk_version\"/" \
  "${repo_name}.gemspec"
rm -f "${repo_name}.gemspec.bak"

# Remove scaffold files (will be completely rewritten later)
git rm -f lib/gem/scaffold.rb lib/gem/scaffold/version.rb sig/gem/scaffold.rbs
[[ -d lib/gem/scaffold ]] && rmdir lib/gem/scaffold
[[ -d lib/gem ]] && rmdir lib/gem
[[ -d sig/gem ]] && rmdir sig/gem

# Create destination directories for new files
mkdir -p "lib/${path_name:h}"
mkdir -p "lib/${path_name}"
mkdir -p "sig/${path_name:h}"

# Rewrite main lib file with proper module nesting and zeitwerk loader
# Split module_names into outer modules and innermost module
innermost_name="${module_names[-1]}"

# Create innermost content (without documentation comment)
innermost_content=$(cat <<EOF
class Error < StandardError; end

loader = Zeitwerk::Loader.for_gem
loader.ignore("#{__dir__}/${path_name:t}/version.rb")
# loader.inflector.inflect(
#   "html" => "HTML",
#   "ssl" => "SSL"
# )
loader.setup
EOF
)

# Wrap with innermost module
content=$(wrap-module "$innermost_name" "$innermost_content")

# Add documentation comment before the innermost module
doc_comment=$(cat <<'EOF'
# CLASS_NAME provides [description of your gem].
#
# This module serves as the namespace for the gem's functionality.
EOF
)
doc_comment=${doc_comment//CLASS_NAME/$class_name}

content=$(cat <<EOF
$doc_comment
$content
EOF
)

# Wrap with outer modules if there are more than one module in the nesting
if [ ${#module_names[@]} -gt 1 ]; then
  outer_names=("${module_names[@]:0:${#module_names[@]}-1}")
  content=$(wrap-modules "$content" outer_names)
fi

cat > "lib/${path_name}.rb" <<EOF
# frozen_string_literal: true

require "zeitwerk"
require_relative "${path_name:t}/version"

$content
EOF

# Rewrite version.rb with proper module nesting
content=$(cat <<'EOF'
VERSION = "0.1.0"
public_constant :VERSION
EOF
)
content=$(wrap-modules "$content" module_names)

cat > "lib/${path_name}/version.rb" <<EOF
# frozen_string_literal: true

$content
EOF

# Rewrite rbs file with proper module nesting
content=$(cat <<EOF
VERSION: String

class Error < StandardError
end
EOF
)
content=$(wrap-modules "$content" module_names)

echo "$content" > "sig/${path_name}.rbs"

# Generate README.md
generate-readme

# Remove files only needed for template repository
git rm bin/initialize
git rm .github/workflows/ADOPTION.md

# Generate binstubs for common gems (using mise to ensure correct Ruby version)
mise exec -- bundle install --quiet
mise exec -- bundle binstubs docquet irb rake rbs rspec-core rubocop yard --force 2>/dev/null || true

# Install RuboCop configuration via docquet
mise exec -- bundle exec docquet install-config --force

# Amend the initial commit with all changes
git add .
git commit --amend -m ":new: Initial commit"

# Configure GitHub repository settings
configure-github-settings

# Print completion message
print-completion-message
