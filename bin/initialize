#!/usr/bin/env zsh

autoload -U colors
colors
# prefix for -x
PS4="${fg[cyan]}[$0:t]$reset_color "
# prefix for stdout
exec > >(sed -e "s/^/${fg[magenta]}[$0:t]$reset_color /")

set -euxo pipefail

# Change to project root directory
cd "$(dirname "$0")/.."

# Check required commands
for cmd in gh mise jq git curl; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "Error: Required command '$cmd' is not installed" >&2
    exit 1
  fi
done

# Inline edit: apply command to file in-place
# Usage: inplace FILE COMMAND [ARGS...]
# Example: inplace myfile.txt sed 's/foo/bar/g'
function inplace()
{
  local file=$1
  shift
  (rm "$file" && "$@" > "$file") < "$file"
}

# Add indentation to each line of input
# Usage: indent N [INPUT]
# Example: echo "hello\nworld" | indent 2
function indent()
{
  local n=$1
  local spaces=$(printf '%*s' $((n * 2)) '')
  sed "/./s/^/$spaces/"
}

# Wrap content with module declaration
# Usage: wrap-module MODULE_NAME CONTENT
# Example: wrap-module MyModule "VERSION = \"1.0.0\""
function wrap-module()
{
  local module_name=$1
  local content=$2

  echo "module $module_name"
  echo "$content" | indent 1
  echo "end"
}

# Wrap content with multiple module declarations (from innermost to outermost)
# Usage: wrap-modules CONTENT MODULE_NAMES_ARRAY
# Example: wrap-modules "VERSION = \"1.0.0\"" module_names
function wrap-modules()
{
  local content=$1
  local array_name=$2

  # Use (P) flag for indirect parameter expansion (zsh way)
  local -a names
  names=("${(@P)array_name}")

  # Wrap from innermost to outermost module
  for ((i=${#names[@]}-1; i>=0; i--)); do
    content=$(wrap-module "${names[$i+1]}" "$content")
  done

  echo "$content"
}

# Generate cron schedule expression from directory path and current time
# Usage: cron-schedule
# Output: '16 8 2-8 1,4 *' (minute: 1-59, hour: 1-23, days 2-8 of Jan/Apr)
function cron-schedule()
{
  # Use full PWD and current timestamp for uniqueness
  local input="${PWD}:$(date +%s)"

  # Calculate hash using SHA256 (via openssl for portability)
  local hash=$(echo -n "$input" | openssl sha256 -r | cut -d' ' -f1)

  # Convert hash to minute (1-59) and hour (1-23), excluding 0
  local minute=$((0x${hash:0:8} % 59 + 1))
  local hour=$((0x${hash:8:8} % 23 + 1))

  # Output cron expression for twice-yearly Ruby version checks
  echo "'$minute $hour 2-8 1,4 *'"
}

# Generate README.md with gem documentation
function generate-readme()
{
  cat > README.md <<EOF
# ${class_name}

TODO: Add a brief description of what this gem does.

## Installation

Add this line to your application's Gemfile:

\`\`\`ruby
gem '${repo_name}'
\`\`\`

And then execute:

\`\`\`bash
bundle install
\`\`\`

Or install it yourself as:

\`\`\`bash
gem install ${repo_name}
\`\`\`

## Usage

\`\`\`ruby
require '${path_name}'

# TODO: Add usage examples
\`\`\`

## Development

After checking out the repo, run \`bin/setup\` to install dependencies. Then, run \`rake spec\` to run the tests. You can also run \`bin/console\` for an interactive prompt that will allow you to experiment.

## Contributing

Bug reports and pull requests are welcome on GitHub at ${repo_url}.

## License

The gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).
EOF
}

# Configure GitHub repository settings via API
function configure-github-settings()
{
  echo ""
  echo "Configuring GitHub repository settings..."

  # Set workflow permissions to read/write and allow PR creation
  if gh api --method PUT repos/:owner/:repo/actions/permissions/workflow \
    -f default_workflow_permissions=write \
    -F can_approve_pull_request_reviews=true 2>/dev/null; then
    echo "✓ Workflow permissions set to 'Read and write'"
    echo "✓ GitHub Actions allowed to create and approve pull requests"
  else
    echo "⚠ Could not configure workflow permissions (may need to be set manually)"
  fi

  # Create release environment
  if gh api --silent --method PUT repos/:owner/:repo/environments/release; then
    echo "✓ Created 'release' environment"
  else
    echo "⚠ Could not create 'release' environment (may need to be created manually)"
  fi
}

# Print completion message with next steps
function print-completion-message()
{
  cat <<'EOF'

==========================================
✓ Gem initialization complete!
==========================================

Next steps:
  1. Configure RubyGems Trusted Publishing at:
     https://rubygems.org/oidc/pending_trusted_publishers

  2. Review the release preparation checklist:
     See .github/workflows/release-preparation.yml for details

  3. Push your changes:
     git push -f origin main

EOF
}

# Update Ruby Versions workflow schedule
cron_schedule=$(cron-schedule)
inplace .github/workflows/update-ruby-versions.yml sed \
  -e "s|# Run at .* UTC .*|# Run at repository-specific time on Jan 2-8 and Apr 2-8 to distribute API load|" \
  -e "s|cron: '[^']*'|cron: $cron_schedule|"

# Generate .ruby_versions.json
gh api -H "Accept: application/vnd.github.raw" repos/ruby/www.ruby-lang.org/contents/_data/branches.yml | \
  ruby -ryaml -rjson -e 'puts JSON.generate(YAML.safe_load(ARGF.read, permitted_classes: [Date]))' | \
  jq '{ruby: [.[] | select(.status | test("maintenance")) | {name, date}] | sort_by(.date) | map(.name | tostring)}' \
  > .ruby_versions.json

# Trust mise configuration to use correct Ruby version
mise trust

# Replace gem names based on current repository name
repo_name=$(basename "$PWD")
path_name=$(echo "$repo_name" | tr '-' '/')
underscore_name=$(echo "$repo_name" | tr '-' '_')

# Generate module nesting for Ruby files
# Example: "my-awesome-gem" -> ["My", "Awesome", "Gem"]
# Example: "my-foo_bar-gem" -> ["My", "FooBar", "Gem"]
IFS='-' read -rA parts <<< "$repo_name"
module_names=()
for part in "${parts[@]}"; do
  # Convert foo_bar to FooBar (capitalize after _ and remove _)
  module_names+=($(echo "$part" | sed -E 's/(^|_)(.)/\U\2/g'))
done

# Generate class name with :: separator from module_names
class_name="${(j.::.)module_names}"

# Get minimum Ruby version from .ruby_versions.json
min_ruby_version=$(jq -r '.ruby[0]' .ruby_versions.json)

# Get author information from git config
author_name=$(git config user.name)
author_email=$(git config user.email)
current_year=$(date +%Y)

# Get repository URL from GitHub
repo_url=$(gh repo view --json url -q .url)

# Replace content in files (README.md is excluded as it contains template instructions)
# Note: lib/sig files are excluded as they will be completely rewritten later
files_to_update=(
  bin/console
  gem-scaffold.gemspec
  spec/spec_helper.rb
)

for file in "${files_to_update[@]}"; do
  [[ -f "$file" ]] || continue
  inplace "$file" sed \
    -e "s/gem-scaffold/$repo_name/g" \
    -e "s/Gem::Scaffold/$class_name/g" \
    -e "s|gem/scaffold|$path_name|g"
done

# Restore executable bit on bin/console (lost during sed inplace edit)
chmod +x bin/console

# Rename gemspec file
git mv gem-scaffold.gemspec "${repo_name}.gemspec"

# Update required_ruby_version in gemspec
inplace "${repo_name}.gemspec" sed \
  -e "s/required_ruby_version = \">= [0-9.]*\"/required_ruby_version = \">= $min_ruby_version\"/"

# Update author information and URLs in gemspec
inplace "${repo_name}.gemspec" sed \
  -e "s/spec.authors = \\[\"[^\"]*\"\\]/spec.authors = [\"$author_name\"]/" \
  -e "s/spec.email = \\[\"[^\"]*\"\\]/spec.email = [\"$author_email\"]/" \
  -e "s|spec.homepage = \"[^\"]*\"|spec.homepage = \"$repo_url\"|"

# Update LICENSE.txt with current year and author
inplace LICENSE.txt sed \
  -e "s/Copyright (c) [0-9]\\{4\\} .*/Copyright (c) $current_year $author_name/"

# Get latest zeitwerk version and update gemspec
zeitwerk_version=$(mise exec -- gem search --remote --exact zeitwerk | grep "^zeitwerk" | sed -E 's/^zeitwerk \(([0-9]+\.[0-9]+)\..*/\1/')
inplace "${repo_name}.gemspec" sed \
  -e "s/\"zeitwerk\", \"~> [0-9.]*\"/\"zeitwerk\", \"~> $zeitwerk_version\"/"

# Remove scaffold files (will be completely rewritten later)
git rm -f lib/gem/scaffold.rb lib/gem/scaffold/version.rb sig/gem/scaffold.rbs
[[ -d lib/gem/scaffold ]] && rmdir lib/gem/scaffold
[[ -d lib/gem ]] && rmdir lib/gem
[[ -d sig/gem ]] && rmdir sig/gem

# Create destination directories for new files
mkdir -p "lib/$(dirname "$path_name")"
mkdir -p "lib/${path_name}"
mkdir -p "sig/$(dirname "$path_name")"

# Rewrite main lib file with proper module nesting and zeitwerk loader
# Split module_names into outer modules and innermost module
innermost_name="${module_names[-1]}"

# Create innermost content (without documentation comment)
innermost_content=$(cat <<EOF
class Error < StandardError; end

loader = Zeitwerk::Loader.for_gem
loader.ignore("#{__dir__}/${path_name:t}/version.rb")
# loader.inflector.inflect(
#   "html" => "HTML",
#   "ssl" => "SSL"
# )
loader.setup
EOF
)

# Wrap with innermost module
content=$(wrap-module "$innermost_name" "$innermost_content")

# Add documentation comment before the innermost module
doc_comment=$(cat <<'EOF'
# CLASS_NAME provides [description of your gem].
#
# This module serves as the namespace for the gem's functionality.
EOF
)
doc_comment=$(echo "$doc_comment" | sed "s/CLASS_NAME/$class_name/")

content=$(cat <<EOF
$doc_comment
$content
EOF
)

# Wrap with outer modules if there are more than one module in the nesting
if [ ${#module_names[@]} -gt 1 ]; then
  outer_names=("${module_names[@]:0:${#module_names[@]}-1}")
  content=$(wrap-modules "$content" outer_names)
fi

cat > "lib/${path_name}.rb" <<EOF
# frozen_string_literal: true

require "zeitwerk"
require_relative "${path_name:t}/version"

$content
EOF

# Rewrite version.rb with proper module nesting
content=$(cat <<'EOF'
VERSION = "0.1.0"
public_constant :VERSION
EOF
)
content=$(wrap-modules "$content" module_names)

cat > "lib/${path_name}/version.rb" <<EOF
# frozen_string_literal: true

$content
EOF

# Rewrite rbs file with proper module nesting
content=$(cat <<EOF
VERSION: String

class Error < StandardError
end
EOF
)
content=$(wrap-modules "$content" module_names)

echo "$content" > "sig/${path_name}.rbs"

# Generate README.md
generate-readme

# Remove initialization script
git rm bin/initialize

# Generate binstubs for common gems (using mise to ensure correct Ruby version)
mise exec -- bundle install --quiet
mise exec -- bundle binstubs docquet irb rake rspec-core rubocop yard --force 2>/dev/null || true

# Install RuboCop configuration via docquet
mise exec -- bundle exec docquet install-config --force

# Amend the initial commit with all changes
git add .
git commit --amend -m ":new: Initial commit"

# Configure GitHub repository settings
configure-github-settings

# Print completion message
print-completion-message
